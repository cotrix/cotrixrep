package org.cotrix;

import static junit.framework.Assert.*;
import static org.cotrix.Fixture.*;
import static org.cotrix.domain.dsl.Codes.*;

import org.cotrix.domain.Attribute;
import org.cotrix.domain.Code;
import org.cotrix.domain.Codebag;
import org.cotrix.domain.Codelist;
import org.cotrix.domain.Container;
import org.cotrix.domain.spi.IdGenerator;
import org.junit.Test;

public class VersioningTest {

	//we answer the question: can DOs be correctly versioned?
	//this applies to codebags and codelists but requires all DOs to yield copies
	//so we mostly answer the question: can DOs be correctly copied?
	
	//we use an ad-hoc generator for the tests
	static IdGenerator generator = new IdGenerator() {
		
		@Override
		public String generateId() {
			return "copied";
		}
	};
	
	@Test
	public void copyHasDifferentIds() {
		
		Attribute.Private a = (Attribute.Private) attr().name(name).value(value).build();
		
		Attribute copy = a.copy(generator);
		
		assertEquals("copied",copy.id());
	}
	
	@Test
	public void copyPreserveName() {
		
		Attribute.Private a = (Attribute.Private) attr().name(name).value(value).build();
		
		Attribute copy = a.copy(generator);
		
		assertEquals(name,copy.name());
	}
	
	@Test
	public void copiesDoNotPreserveDeltas() {
		
		Attribute.Private a = (Attribute.Private) attr().add().name(name).value(value).build();
		
		Attribute.Private copy = a.copy(generator);
		
		assertNull(copy.change());
	}
	
	@Test
	public void attributesCanBeCopied() {
		
		//little trick: we give object the same id that will be generated by our test generator
		//we can then use equality
		Attribute.Private a = (Attribute.Private) attr(generator.generateId()).name(name).value(value).in(language).build();
		
		Attribute copy = a.copy(generator);
		
		assertEquals(a,copy);
		
		
	}
	
	@Test
	public void bagsCanBeCopied() {
		
		//little trick: we give object the same id that will be generated by our test generator
		//we can then use equality
		Attribute.Private a = (Attribute.Private) attr(generator.generateId()).name(name).value(value).build();
		Attribute.Private a2 = (Attribute.Private) attr(generator.generateId()).name(name2).value(value2).build();
		
		Container.Private<Attribute.Private> bag = bag(a,a2);
		
		Container.Private<Attribute.Private> clone = bag.copy(generator);
		
		assertEquals(bag,clone);
		
		//copy is recursive
		assertNotSame(asMap(bag).get(name).get(0), asMap(clone).get(name).get(0));

	}

	
	@Test
	public void codesCanBeCopied() {

		//little trick: we give object the same id that will be generated by our test generator
		//we can then use equality
		Attribute a = attr(generator.generateId()).name(name).value(value).build();
		Attribute a2 = attr(generator.generateId()).name(name2).value(value2).build();
				
		Code.Private code = (Code.Private) code(generator.generateId()).name(name).attributes(a,a2).build();
		
		Code.Private copy = code.copy(generator);
		
		assertEquals(code,copy);
		
		//copy is recusive
		assertNotSame(code.attributes(), copy.attributes());

	}
	
	@Test(expected=IllegalStateException.class)
	public void versioningRequiresIdentifier() {
	
		Codelist.Private list = (Codelist.Private) codelist().name(name).version(version).build(); 
		
		list.bump(generator,"new");
	}
	
	@Test
	public void codelistsCanBeVersioned() {

		Code.Private code = (Code.Private) code(generator.generateId()).name(name).build();
		
		Codelist.Private list = (Codelist.Private) codelist("1").name(name).with(code).version(version).build(); 
				
		//a new version of the list
		Codelist versioned = list.bump(generator,"2");
				
		assertEquals("2",versioned.version());
				
		//the new version is a fork
		assertFalse(list.equals(versioned));
		
		
		assertEquals(list.codes(), versioned.codes());
		
		//copy is recusive
		assertNotSame(list.codes(), versioned.codes());
		
	}
	
	@Test
	public void codebagsCanBeVersioned() {

		Codelist.Private list = (Codelist.Private) codelist(generator.generateId()).name(name).build();
		
		Codebag.Private bag = (Codebag.Private) codebag("1").name(name).with(list).version(version).build(); 
				
		//a new version of the list
		Codebag versioned = bag.bump(generator,"2");
				
		assertEquals("2",versioned.version());
				
		//the new version is a fork
		assertFalse(bag.equals(versioned));
		
		assertEquals(bag.lists(), versioned.lists());
		
		//copy is recusive
		assertNotSame(bag.lists(), versioned.lists());
	}
	
	@Test(expected=IllegalStateException.class)
	public void versionsMustBeConsistent() {
		
		Codelist.Private list = (Codelist.Private) codelist("1").name(name).version("2").build(); 
		
		//a failed attempt to version the list with an unacceptable number
		list.bump(generator,"1.3");
		
	}
	
	
	

}
